{"version":3,"sources":["libs/components/timer.js","libs/components/controls.js","libs/components/savedTime.js","libs/components/list.js","App.js","reportWebVitals.js","index.js"],"names":["Timer","timeElapsed","dateStamp","totSec","sec","mins","hrs","console","log","id","toString","padStart","className","defaultProps","Controls","props","handleStart","bind","handlePause","handleReset","handleSave","this","startTime","pauseTime","resetTime","saveTime","onClick","React","PureComponent","SavedTime","delRecord","deleteLI","timeRecord","date","style","display","time","padding","fontSize","Component","List","delTime","date2Del","delete","savedTimes","list","sort","timerA","timerB","map","timer","length","App","state","running","saved","deleteTime","clockTick","now","Date","getMonth","getDate","getFullYear","getHours","getMinutes","getSeconds","setState","clear","newTimeRecord","timeDate","filter","timeObj","maxTime","setTimeout","Fragment","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","maxtTime","Style","document","getElementById"],"mappings":"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","file":"static/js/main.1c086b64.chunk.js","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Timer = function ({ timeElapsed, dateStamp }) {\n  /** this component behaves as a display of the current instance of a running timer.\n   * it shows the current time elapsed and should update every time a second passes\n   */\n  // parse total seconds into a digital clock display format:\n  // only parse the timer if there is a time elapsed, otherwise display all zeroes\n  if (timeElapsed > 0) {\n    // if there is a totalElapsed time, render it dynamically\n    let totSec = timeElapsed;\n    let sec = totSec % 60;\n    let mins_hrs = totSec - sec; // total number of seconds that add up to complete minutes\n    // total seconds with remainder (less than 60 sec) cut off\n    let mins = (mins_hrs / 60) % 60; // total minutes less than an hour\n    let hrs = (totSec - (totSec % 3600)) / 3600; // hours\n\n    console.log(`totSec=${totSec}:_ hrs=${hrs}, min=${mins}, sec=${sec}`);\n\n    return (\n      <div id=\"timeAndStamp\">\n        <span id=\"timerString\">\n          {hrs.toString().padStart(2, '0')}:{mins.toString().padStart(2, '0')}:\n          {sec.toString().padStart(2, '0')}\n        </span>\n        <br />\n        <span>Date started: {dateStamp}</span>\n      </div>\n    );\n  } else {\n    // if no time has elapsed or timer is not currently active, show all zeroes\n    return (\n      <div id=\"timer\">\n        <span className=\"timer\">00:00:00</span>\n      </div>\n    );\n  }\n};\nTimer.defaultProps = {\n  timeElapsed: 0,\n  dateStamp: '',\n};\nTimer.propTypes = {\n  timeElapsed: PropTypes.number.isRequired,\n  dateStamp: PropTypes.string.isRequired,\n};\nexport default Timer;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nclass Controls extends React.PureComponent {\n  // switched to \"PureComponent\" in hopes of avoiding unnecessary re-renders.\n  // This component should theoretically not receive any props that are\n  // different from when it initially is mounted\n  constructor(props) {\n    super(props);\n    this.handleStart = this.handleStart.bind(this);\n    this.handlePause = this.handlePause.bind(this);\n    this.handleReset = this.handleReset.bind(this);\n    this.handleSave = this.handleSave.bind(this);\n  }\n\n  handleStart() {\n    this.props.startTime(); // tell App.js to start the timer\n  }\n  handlePause() {\n    this.props.pauseTime(); // tell App.js to pause the timer\n  }\n  handleReset() {\n    this.props.resetTime(); // tell App.js to reset the timer\n  }\n  handleSave() {\n    this.props.saveTime(); // tell App.js to save the current instance of timer\n  }\n\n  render() {\n    return (\n      <>\n        <button className={'good-button'} onClick={this.handleStart}>Start</button>&nbsp;\n        <button className={'neutral-button'} onClick={this.handlePause}>Pause</button>&nbsp;\n        <button className={'bad-button'} onClick={this.handleReset}>Reset</button>&nbsp;\n        <button className={'neutral-button'} onClick={this.handleSave}>Save</button>\n      </>\n    );\n  }\n}\nControls.propTypes = {\n  startTime: PropTypes.func.isRequired,\n  pauseTime: PropTypes.func.isRequired,\n  resetTime: PropTypes.func.isRequired,\n  saveTime: PropTypes.func.isRequired,\n};\nexport default Controls;\n","import React from 'react';\nimport { default as Timer } from './timer';\nimport PropTypes from 'prop-types';\n\nclass SavedTime extends React.Component {\n  constructor(props) {\n    super(props);\n    this.delRecord = this.delRecord.bind(this);\n  }\n\n  delRecord() {\n    this.props.deleteLI(this.props.timeRecord.date); // calls a chain of methods all the way up to App\n    // in order to delete this specific instance of <SavedTime> from App.state\n  }\n\n  render() {\n    const listStyle = {\n      padding: '0.8em',\n      fontSize: '0.8em' \n    }\n    return (\n      <>\n        {\n          <Timer\n            style={{display:'inline-block'}}\n            timeElapsed={this.props.timeRecord.time}\n            dateStamp={this.props.timeRecord.date}\n          />\n        }\n        <button className={'bad-button'} style={listStyle}\n        onClick={this.delRecord}>&nbsp;X&nbsp;</button>\n      </>\n    );\n  }\n}\n\nSavedTime.propTypes = {\n  timeRecord: PropTypes.object.isRequired,\n  deleteLI: PropTypes.func.isRequired,\n};\nexport default SavedTime;\n","import React from 'react';\nimport { default as SavedTime } from './savedTime';\nimport PropTypes from 'prop-types';\n\nclass List extends React.Component {\n  constructor(props) {\n    super(props);\n    this.delTime = this.delTime.bind(this);\n  }\n\n  delTime(date2Del) {\n    // parameter: date to delete\n    this.props.delete(date2Del);\n    // delete the record from the list\n  }\n\n  render() {\n    const ordered = this.props.list.sort(\n      (timerA, timerB) => timerA.time >= timerB.time\n    ); // sort times by stortest to longest\n    const savedTimes = ordered.map((timer) => (\n      <li key={timer.date}>\n        <SavedTime timeRecord={timer} deleteLI={this.delTime} />\n      </li>\n    ));\n    // delTime calls the App's delete method\n    // make sure the list can pull both the time and it's stamp identifier:\n    // add stamp parameter to .map() callback somehow\n    // add \"personal record\" indicator to best time\n    if (savedTimes.length > 0) {\n      return (\n        <>\n          <p>Saved times:</p>\n          <ol>{savedTimes}</ol>\n        </>\n      );\n    } else {\n      // handle case where list is empty:\n      return <p>No saved times yet...</p>;\n    }\n  }\n}\nList.propTypes = {\n  list: PropTypes.array.isRequired,\n  delete: PropTypes.func.isRequired,\n};\nexport default List;\n","import React from 'react';\nimport { default as Timer } from './libs/components/timer';\nimport { default as Controls } from './libs/components/controls';\nimport { default as List } from './libs/components/list';\nimport PropTypes from 'prop-types';\n//import './App.css';\nimport './libs/style/nick-style-lib.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      running: false, // timer is activated by pressing <Start>, deactivated by pressing <Stop> button\n      time: 0, // number of seconds elapsed since pressing <Start> button\n      date: '', // will hold date/time associated with when the timer was started\n      saved: [], // list of saved times, stored as total seconds for easy comparsion\n      // the <List/> and <Timer/> components will display these times parsed out into {00:00:00} format\n    };\n    this.startTime = this.startTime.bind(this);\n    this.pauseTime = this.pauseTime.bind(this);\n    this.resetTime = this.resetTime.bind(this);\n    this.saveTime = this.saveTime.bind(this);\n    this.deleteTime = this.deleteTime.bind(this);\n    this.clockTick = this.clockTick.bind(this);\n  }\n\n  startTime() {\n    if (this.state.running) {\n      return; // if the timer is already running when start is pushed, this function should just terminate and\n      // let the current clock-tick loop continue\n    } else {\n      console.log('start button hit');\n      let now = new Date(); // get the current date and save it as a stamp to identify the time for when/if it gets saved\n      let dateStamp = ` Time on ${\n        now.getMonth() + 1\n      }-${now.getDate()}-${now.getFullYear()}\\\n       at ${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`; // template literal for displaying date:\n      // example:{ MM-DD-YYY at 12:56:03 }\n      console.log(dateStamp + ' = dateStamp for this instance of timer');\n\n      this.setState({\n        date: dateStamp, // keep track of when the timer started\n        running: true, // set <running> to True so the clock-tick loop will be able to run\n      });\n    }\n  }\n\n  pauseTime() {\n    console.log('pause button hit');\n    this.setState({\n      running: false, // set App.state.running to <false>, which should end <clockTick> loop\n      // but leave time at its current value, in case user wants to continue timing\n    });\n  }\n\n  resetTime() {\n    console.clear();\n    console.log('reset button hit');\n    this.setState({\n      running: false, // if Reset button is pushed, it should stop any timer that might already be running\n      time: 0, // reset/overwrite time elapsed to 0\n      date: '',\n    });\n    console.log('time? ' + this.state.time);\n  }\n\n  saveTime() {\n    // save button can save the most recent time and also stop any timer that might be running\n    console.clear();\n    console.log('save button hit');\n    if (this.state.time === 0) {\n      return; // avoids duplicate key problem in saved list when <Save> button hit twice\n    }\n    let timeToSave = this.state.time;\n    let newTimeRecord = {\n      // new time obejct which will be a completed timer and the date it was started\n      time: timeToSave,\n      date: this.state.date,\n    };\n    this.setState({\n      running: false, // any running timer should be stopped if Save button is pushed\n      saved: [...this.state.saved, newTimeRecord], // append new time to the list\n      time: 0, // reset to 0 so timer can be used again starting from 0\n    });\n    console.log('saved: ' + newTimeRecord.time + ' ' + newTimeRecord.date);\n    // if {App.state.time > 0}, save in App.state and pass all the times to the <List> component\n    // then <List> component should dynamically render the list of saved times\n  }\n\n  deleteTime(timeDate) {\n    // date of timer will be a parameter\n    this.setState({\n      saved: this.state.saved.filter((timeObj) => timeObj.date !== timeDate),\n    });\n  }\n\n  clockTick() {\n    if (this.state.running && this.state.time <= this.props.maxTime) {\n      this.setState({\n        time: this.state.time + 1, // increment the number of seconds elapsed since pressing <start> button\n      });\n    } else {\n      return; // do not increment time-elapsed if the timer is no longer running or it's reached the max\n    }\n  }\n\n  componentDidUpdate() {\n    console.log('time elapsed: ' + this.state.time);\n    if (this.state.running) {\n      setTimeout(this.clockTick, 990); // wait almost a full second,\n      // then increment time-elapsed if App.state.running is still true\n    }\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        <div className=\"App\">\n          <h1>Stopwatch</h1>\n          <Timer\n            timeElapsed={this.state.time}\n            dateStamp={this.state.date}\n          />{' '}\n          {/*render <Timer> and \n          override its timeElapsed prop with updated time from App.state.\n          also override its dateStamp so it can be identified in a list of saved times*/}\n          <Controls\n            running={this.state.running}\n            startTime={this.startTime}\n            pauseTime={this.pauseTime}\n            resetTime={this.resetTime}\n            saveTime={this.saveTime}\n          />{' '}\n          {/*let the controls know whether the timer is running, and allow the buttons to access App's methods */}\n          <List list={this.state.saved} delete={this.deleteTime} />\n        </div>\n      </React.Fragment>\n    );\n  }\n}\nApp.defaultProps = { maxTime: 172800 }; // default maxTime of 48 hours (written in seconds) to prevent infinite loop\nApp.propTypes = { maxTime: PropTypes.number.isRequired };\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport * as Style from './libs/style/nick-style-lib.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App maxtTime={259200} style={Style}/>\n    {/*maxTime prop is meant to prevent an infinite loop in case the stop button is never pressed\n      here, its default is overridden to 3 days instead of 2 (259200 seconds in 3 days)\n    */}\n  </React.StrictMode>,\n  document.getElementById('root')\n); // App renders with functioning timer, saved/sorted list, and delete button removes correct time. 10/28/21\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n// test message to see if repo is connected to github now\n"],"sourceRoot":""}